import { Tabs } from 'nextra/components'

# Getting Started

This guide will walk you through the basic setup and usage of the core utilities.

## Installation

<Tabs items={['npm', 'yarn', 'pnpm', 'bun']} storageKey="cladi-install-tabs">
  <Tabs.Tab>
    ```bash copy
    npm install @elsikora/cladi
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```bash copy
    yarn add @elsikora/cladi
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```bash copy
    pnpm add @elsikora/cladi
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```bash copy
    bun install @elsikora/cladi
    ```
  </Tabs.Tab>
</Tabs>

## Basic Usage

Here's a simple example of creating and using the core components:

```typescript filename="basic-usage.ts" copy
import {
	createContainer,
	createRegistry,
	createFactory,
	createLogger,
	ELoggerLogLevel,
	type IContainer,
	type IRegistry,
	type IFactory,
	type ILogger,
} from "@elsikora/cladi"; // Adjust import path as needed

// Define unique Symbols for keys/tokens
const BasicTokens = {
	MyItem: Symbol.for("MyItem"),
	Logger: Symbol.for("BasicLogger"),
	Registry: Symbol.for("BasicRegistry"),
	Factory: Symbol.for("BasicFactory"),
};

// 1. Create a Logger
const logger: ILogger = createLogger({ level: ELoggerLogLevel.DEBUG, source: "BasicExample" });
logger.info("Logger created.");

// 2. Create a Registry
interface MyItem { value: number; } // Key is the Symbol, not part of the object
const registryOptions = { logger };
const registry: IRegistry<MyItem> = createRegistry<MyItem>(registryOptions);
// Register using the Symbol key
registry.register(BasicTokens.MyItem, { value: 100 });
logger.info("Registry created and item registered.");

// 3. Create a Factory
const factoryOptions = { registry, logger };
const factory: IFactory<MyItem> = createFactory<MyItem>(factoryOptions);
// Create using the Symbol key
const myItemInstance = factory.create(BasicTokens.MyItem);
logger.info(`Item created via factory: ${JSON.stringify(myItemInstance)}`);

// 4. Create a Container
const containerOptions = { logger, name: Symbol.for("BasicContainer") }; // Give container a name
const container: IContainer = createContainer(containerOptions);

// Register services/components using Tokens
container.register(BasicTokens.Logger, logger);
container.register(BasicTokens.Registry, registry);
container.register(BasicTokens.Factory, factory);
logger.info("Container created and components registered.");

// Retrieve a service using its Token
const retrievedLogger = container.get<ILogger>(BasicTokens.Logger);
retrievedLogger?.info("Logger retrieved from container.");

// Retrieve the item created by the factory (if factory was registered)
// Note: Typically you register services or constructors, not factory instances directly like this
// unless the factory *is* the service you want.
// const retrievedFactory = container.get<IFactory<MyItem>>(BasicTokens.Factory);
// const itemFromContainerFactory = retrievedFactory?.create(BasicTokens.MyItem);
// logger.info(`Item from container factory: ${JSON.stringify(itemFromContainerFactory)}`);

```

This example demonstrates the basic workflow of initializing and using the logger, registry, factory, and container.

## Full Integration Example (Multi-File)

Let's structure a small application using `@elsikora/cladi`.

**1. Define Types & Tokens (`src/types.ts`)**

```typescript filename="src/types.ts" copy
// Define configuration structure
export interface IAppConfig {
  logLevel: "debug" | "info" | "warn" | "error" | "trace";
  apiUrl: string;
}

// Define a service interface
export interface IUserService {
  getUser(id: number): Promise<{ id: number; name: string } | null>;
}

// Define unique Symbols for dependency injection tokens
export const Tokens = {
  Logger: Symbol.for("Logger"),
  AppConfig: Symbol.for("AppConfig"),
  UserService: Symbol.for("UserService"),
  // Add tokens for any other injectable service
};

// Define a Symbol for the main application container name
export const AppContainerName = Symbol.for("AppContainer");
```

**2. Create Services (`src/services.ts`)**

```typescript filename="src/services.ts" copy
import { Injectable, Inject } from "@elsikora/cladi";
import type { IUserService, IAppConfig } from "./types";
import { Tokens, AppContainerName } from "./types";
import type { ILogger } from "@elsikora/cladi";

// Mark the class as injectable and associate it with the AppContainer
@Injectable(AppContainerName)
export class UserServiceImpl implements IUserService {

  // Use @Inject decorator to specify dependencies
  constructor(
    @Inject(Tokens.AppConfig) private readonly config: IAppConfig,
    @Inject(Tokens.Logger) private readonly logger: ILogger
  ) {
    this.logger.debug("UserService initialized via DI", { source: "UserServiceImpl" });
  }

  async getUser(id: number): Promise<{ id: number; name: string } | null> {
    this.logger.info(`Fetching user with id: ${id}`, {
      source: "UserServiceImpl",
      context: { apiUrl: this.config.apiUrl },
    });
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 50));
    if (id === 1) {
      return { id: 1, name: "Alice" };
    }
    return null;
  }
}
```

**3. Configure Container (`src/container-config.ts`)**

```typescript filename="src/container-config.ts" copy
import {
  createContainer,
  createLogger,
  ELoggerLogLevel,
  type IContainer,
  type ILogger,
} from "@elsikora/cladi";
import { type IAppConfig, Tokens, AppContainerName } from "./types";
import { UserServiceImpl } from "./services"; // Import the class

// Define configurations (could also come from files/env vars)
const devConfig: IAppConfig = {
  logLevel: ELoggerLogLevel.DEBUG,
  apiUrl: "http://localhost:3000/api",
};
const prodConfig: IAppConfig = {
  logLevel: ELoggerLogLevel.INFO,
  apiUrl: "https://api.example.com/v1",
};

// Determine environment
const env = process.env.NODE_ENV === 'production' ? 'production' : 'development';
const appConfig = env === 'production' ? prodConfig : devConfig;

// --- Logger ---
const logger: ILogger = createLogger({ level: appConfig.logLevel, source: "App" });

// --- Main Application Container ---
// Create the container with its designated name
const container: IContainer = createContainer({ name: AppContainerName, logger });

// Register core services/config
container.register(Tokens.Logger, logger);
container.register(Tokens.AppConfig, appConfig);

// Register injectable classes
// The container will automatically resolve dependencies marked with @Inject
// when UserServiceImpl is requested via Tokens.UserService
container.register(Tokens.UserService, UserServiceImpl);

logger.info(`Application configured for [${env}] environment.`, {
  context: { config: appConfig },
});

export { container }; // Export the configured container
```

**4. Application Entry Point (`src/main.ts`)**

```typescript filename="src/main.ts" copy
import { container } from "./container-config";
import { type IUserService, Tokens } from "./types";
import { type ILogger } from "@elsikora/cladi";

async function main() {
  // Get services from the container using tokens
  const logger = container.get<ILogger>(Tokens.Logger);
  // Requesting UserService by its token triggers DI resolution
  const userService = container.get<IUserService>(Tokens.UserService);

  if (!logger || !userService) {
    console.error("Failed to retrieve essential services from container!");
    process.exit(1);
  }

  logger.info("Application starting...");

  const user = await userService.getUser(1);
  if (user) {
    logger.info(`Found user: ${user.name}`);
  } else {
    logger.warn("User with ID 1 not found.");
  }

  const nonExistentUser = await userService.getUser(2);
  if (!nonExistentUser) {
    logger.info("User with ID 2 correctly not found.");
  }

  logger.info("Application finished.");
}

main().catch(error => {
  let logger: ILogger | undefined;
  try {
    logger = container.get<ILogger>(Tokens.Logger);
  } catch {
    // Container or logger might not be available if error happened early
  }

  if (!logger) {
    console.error("Logger not available, logging error directly:", error);
  } else if (error instanceof Error) {
    logger.error(`Unhandled error: ${error.message}`, { context: { stack: error.stack } });
  } else {
    logger.error("Unhandled non-error thrown", { context: { error } });
  }
  process.exit(1);
});

```

This updated example shows how to:
- Define shared `Symbol` tokens for services and configuration.
- Define a `Symbol` for the container name.
- Use the `@Injectable(ContainerName)` decorator on services.
- Use the `@Inject(Token)` decorator on constructor parameters.
- Register the *class constructor* (`UserServiceImpl`) with the container under its token.
- Let the container handle the instantiation and dependency injection when `container.get(Token)` is called.
- Retrieve and use services from the container in the main application logic. 
