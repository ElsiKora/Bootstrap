import { Callout } from 'nextra/components'
import { unstable_TSDoc as TSDoc } from 'nextra/tsdoc'

# Error Handling

Consistent error handling is essential for building robust applications. ClaDI promotes a standardized approach through the `IError` interface and the `BaseError` implementation.

## `IError` Interface

This interface defines the common structure for errors within applications using ClaDI.

<TSDoc code={`import type { IError } from '@elsikora/cladi'; export default IError`} />

It extends the standard JavaScript `Error` object and adds:

-   `CODE`: A mandatory, unique string code identifying the type of error (e.g., `"USER_NOT_FOUND"`, `"INVALID_INPUT"`, `"DATABASE_CONNECTION_FAILED"`). This is useful for programmatic error handling.
-   `CAUSE`: (Optional) The original error that triggered this one, allowing for error chaining and preserving stack traces.
-   `context`: (Optional) A `Record<string, unknown>` containing additional relevant information about the error (e.g., the invalid input value, the ID that wasn't found).

## `BaseError` Class

ClaDI provides `BaseError` as a concrete implementation of `IError`. It simplifies creating structured errors.

```typescript filename="src/custom-error.ts" copy
import { BaseError } from '@elsikora/cladi';

export class AuthenticationError extends BaseError {
  constructor(message: string, context?: Record<string, unknown>, cause?: Error) {
    super(message, {
      code: 'AUTH_FAILED', // Specific code for this error type
      source: 'AuthService', // Identify where the error originated
      context,
      cause,
    });
  }
}

// Example usage:
function authenticateUser(userId: string | null) {
  if (!userId) {
    throw new AuthenticationError('User ID is required for authentication.', {
      missingField: 'userId',
    });
  }

  try {
    // ... attempt authentication, which might throw another error
    // fakeDb.findUser(userId);
  } catch (dbError) {
    throw new AuthenticationError(`Authentication failed for user ${userId}`, {
      userId,
    }, dbError instanceof Error ? dbError : undefined);
  }
}
```

### `BaseError` Options (`IBaseErrorOptions`)

The `BaseError` constructor takes the error `message` and an options object:

<TSDoc code={`import type { IBaseErrorOptions } from '@elsikora/cladi'; export default IBaseErrorOptions`} />

-   `code`: (Required) The unique error code string.
-   `cause`: (Optional) The underlying error.
-   `context`: (Optional) Additional context data.
-   `source`: (Optional) A string identifying the module or class where the error originated.

## Throwing and Catching

You typically `throw` instances of `BaseError` (or custom errors extending it) when an exceptional situation occurs. You can then `catch` these errors and inspect their properties for specific handling.

```typescript filename="src/error-handling.ts" copy
import { BaseError } from '@elsikora/cladi';
import { AuthenticationError } from './custom-error'; // Assuming previous example

try {
  // Code that might throw AuthenticationError or other BaseErrors
  // authenticateUser(null);
} catch (error) {
  if (error instanceof BaseError) {
    console.error(`[${error.SOURCE ?? 'UnknownSource'}] (${error.CODE}): ${error.message}`);
    if (error.context) {
      console.error('  Context:', error.context);
    }
    if (error.cause) {
      console.error('  Cause:', error.cause);
    }

    // Specific handling based on code
    if (error.CODE === 'AUTH_FAILED') {
      // Redirect to login or show specific message
    } else if (error.CODE === 'VALIDATION_ERROR') {
      // Return a 400 Bad Request response
    }
  } else {
    // Handle unexpected, non-BaseError errors
    console.error('An unexpected error occurred:', error);
  }
}
```

## Benefits

-   **Consistency:** Provides a uniform structure for all application errors.
-   **Information Rich:** Includes codes, sources, context, and causal errors for better debugging.
-   **Programmatic Handling:** Allows reliable error identification and branching logic using the `CODE` property.
-   **Clear Origin:** The optional `source` helps pinpoint where errors originate in larger systems.

By consistently using `BaseError` or extending it for specific error types, you create a more predictable and maintainable error-handling strategy. 