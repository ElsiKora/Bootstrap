import { unstable_TSDoc as TSDoc } from 'nextra/tsdoc'

# Container Pattern

The `Container` is the heart of the dependency injection (DI) system provided by `@elsikora/cladi`. DI is a fundamental design pattern that promotes loose coupling and testability by allowing components to receive their dependencies from an external source (the container) rather than creating them internally.

Think of the container as a central hub where you register all the building blocks (services, configurations, etc.) of your application. When a component needs a building block, it asks the container for it.

## Key Features & Examples

- **Registration (`register`/`registerMany`)**: Store dependencies using a unique `symbol` as a key (token). You should create your own `Symbol.for('YourToken')` for application-specific dependencies.

  ```typescript filename="src/container-setup.ts" copy
  import { createContainer, type ILogger } from '@elsikora/cladi';
  import { SomeService, AnotherService } from './services';
  import { ApiConfig } from './config';
  import { Tokens } from './types';

  // Assume logger is created elsewhere
  declare const logger: ILogger;
  const container = createContainer({ logger });

  // Create instances of your services/configs
  const apiConfig = new ApiConfig();
  const someService = new SomeService(apiConfig); // Manual injection for this example
  const anotherService = new AnotherService(logger); // Manual injection

  // Define custom tokens
  const Tokens = {
    ApiConfig: Symbol.for('ApiConfig'),
    SomeService: Symbol.for('SomeService'),
    AnotherService: Symbol.for('AnotherService'),
  };

  // Register dependencies
  container.register(Tokens.Logger, logger);
  container.register(Tokens.ApiConfig, apiConfig);
  container.register(Tokens.SomeService, someService);
  container.register(Tokens.AnotherService, anotherService);
  
  logger.info("Dependencies registered in the container.");
  
  export { container, Tokens }; // Export for use elsewhere
  ```

- **Retrieval (`get`/`getMany`)**: Fetch dependencies using their registered token. The type parameter `<T>` ensures type safety.

  ```typescript filename="src/some-module.ts" copy
  import { container, Tokens } from './container-setup';
  import { type ILogger } from '@elsikora/cladi';
  import type { SomeService } from './services';
  import type { ApiConfig } from './config';

  function doSomething() {
    // Retrieve needed services from the container
    const logger = container.get<ILogger>(Tokens.Logger);
    const service = container.get<SomeService>(Tokens.SomeService);
    const config = container.get<ApiConfig>(Tokens.ApiConfig);

    if (!logger || !service || !config) {
        // Using console.error as logger might be undefined
        console.error("Required dependencies not found in container!");
        return;
    }

    logger.info("Doing something with the service...", { source: "someModule" });
    service.performAction(config.getApiKey());
  }
  ```

- **Checking Existence (`has`)**: Verify if a token is registered before attempting retrieval.
  ```typescript filename="src/check-existence.ts" copy
  declare const logger: ILogger;
  if (container.has(Tokens.SomeService)) {
    const service = container.get<SomeService>(Tokens.SomeService);
    // ... use service safely
  } else {
    logger.warn("SomeService is not available in the container.");
  }
  ```

- **Unregistration (`unregister`/`unregisterMany`)**: Remove dependencies, useful in testing or dynamic scenarios (less common in typical application flow).
  ```typescript filename="src/unregister-example.ts" copy
  declare const logger: ILogger;
  container.unregister(Tokens.SomeService);
  logger.debug(`Has SomeService after unregister: ${container.has(Tokens.SomeService)}`); // Logs: false
  ```

- **Clearing (`clear`)**: Remove all registered dependencies, primarily for test environment teardown to ensure test isolation.
  ```typescript filename="src/clear-example.ts" copy
  declare const logger: ILogger;
  container.clear();
  logger.debug(`Has Logger after clear: ${container.has(Tokens.Logger)}`); // Logs: false
  ```

## Decorator-Based Injection (@Injectable / @Inject)

While manual registration is always possible, the container truly shines when used with the `@Injectable` and `@Inject` decorators. This automates the process of dependency resolution.

1.  **Mark Services as Injectable**: Use `@Injectable(ContainerName)` on your service class. `ContainerName` must be the `Symbol` used when creating the container instance with `createContainer({ name: ContainerName })`.
2.  **Declare Dependencies**: Use `@Inject(Token)` on constructor parameters to tell the container which dependency (identified by `Token`) should be injected for that parameter.
3.  **Register the Class**: Register the *class constructor itself* with the container using its token: `container.register(Tokens.MyService, MyServiceClass);`
4.  **Retrieve the Instance**: When you call `container.get<IMyService>(Tokens.MyService)`, the container will:
    *   See that `MyServiceClass` is registered.
    *   Check its `@Injectable` metadata to ensure it belongs to this container.
    *   Examine the constructor's `@Inject` metadata.
    *   Recursively call `get()` for each required dependency token.
    *   Instantiate `MyServiceClass` with the resolved dependencies.
    *   Cache and return the instance (singleton scope by default).

```typescript filename="src/decorator-di-example.ts" copy
import { createContainer, Injectable, Inject, type IContainer, type ILogger } from "@elsikora/cladi";

// 1. Define Tokens and Container Name
const DiTokens = {
  Logger: Symbol.for("DiLogger"),
  DataFetcher: Symbol.for("DataFetcher"),
  ReportGenerator: Symbol.for("ReportGenerator"),
};
const DiContainerName = Symbol.for("DiContainer");

// 2. Define Interfaces
interface IDataFetcher { fetchData(): string; }
interface IReportGenerator { generate(): void; }

// 3. Implement Services with Decorators
@Injectable(DiContainerName)
class ApiDataFetcher implements IDataFetcher {
  constructor(@Inject(DiTokens.Logger) private logger: ILogger) {
    this.logger.debug("ApiDataFetcher constructed");
  }
  fetchData(): string { return "Data from API"; }
}

@Injectable(DiContainerName)
class ReportGeneratorImpl implements IReportGenerator {
  constructor(
    @Inject(DiTokens.Logger) private logger: ILogger,
    @Inject(DiTokens.DataFetcher) private fetcher: IDataFetcher
  ) {
    this.logger.debug("ReportGenerator constructed");
  }
  generate(): void {
    const data = this.fetcher.fetchData();
    this.logger.info(`Generating report with: ${data}`);
    // ... generation logic ...
  }
}

// 4. Setup Container and Register
declare const baseLogger: ILogger; // Assume a base logger exists
const diContainer: IContainer = createContainer({ name: DiContainerName, logger: baseLogger });

diContainer.register(DiTokens.Logger, baseLogger); // Register shared logger
diContainer.register(DiTokens.DataFetcher, ApiDataFetcher); // Register the class
diContainer.register(DiTokens.ReportGenerator, ReportGeneratorImpl); // Register the class

// 5. Use the Service
// Getting ReportGenerator triggers resolution of DataFetcher and Logger
const reportGenerator = diContainer.get<IReportGenerator>(DiTokens.ReportGenerator);
reportGenerator.generate();
```

This approach significantly reduces boilerplate for wiring up dependencies, especially in larger applications.

## Benefits

- **Loose Coupling**: Components depend only on abstract tokens (symbols) and interfaces, not on the concrete classes or how they are created. This makes your system more flexible and easier to refactor.
- **Enhanced Testability**: In unit tests, you can register mock implementations of services under the same tokens, completely isolating the component under test from its real dependencies.
- **Improved Reusability & Maintainability**: Components become more modular and self-contained. Managing dependencies is centralized in the container setup, making the overall application structure clearer.

## Core Implementation

- **`IContainer` (Interface)**: Located in `src/domain/interface/container.interface.ts`. Defines the essential methods (`register`, `get`, `has`, etc.) that any container must implement.
- **`BaseContainer` (Class)**: Located in `src/infrastructure/class/base/container.class.ts`. The default, concrete implementation provided by the library. It includes built-in logging for container operations (if a logger is provided) to aid debugging.
- **`createContainer` (Utility)**: Exported from the library root (`import { createContainer } from '@elsikora/cladi';`). A convenient factory function to instantiate `BaseContainer`. It accepts `IBaseContainerOptions`, primarily used for injecting a logger into the container itself.

### Base Implementation Options (`IBaseContainerOptions`)

<TSDoc code={`import type { IBaseContainerOptions } from '@elsikora/cladi';
export default IBaseContainerOptions`} />
